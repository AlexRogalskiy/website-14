{"all": [{"username": "ohjames", "name": "Mr Friend", "title": "The state of web asset pipelines and the description of a new pipeline that combines the best of all worlds.", "avatar": "https://avatars.githubusercontent.com/u/97685?v=3", "date": "May 27th 2015", "desc": "People soon realised that a task runner is not an asset pipeline, maybe sometime after the millionth spaghetti gruntfile was written. Along came gulp, the wonderful streaming pipeline, but the people saw that it was flawed, being built around `1:1` operations (disallowing nice n:1 stuff such as concatenation of streams together with their source maps).<br><br>Then came plumber, broccoli, gobble, and metalsmith, all with unique selling points yet all having drawbacks not found in grunt and/or gulp.<br><br>It was time for a new asset pipeline to be born out of the pain of trying to find the holy grail of asset pipelines. It was time to write it using functional reactive programming, ES6 and a geekgasm of buzz-words to seduce the JavaScript community. It was time for a bullshit sensationalised lnug talk abstract. Yes, it's time to sigh. <a href='https://github.com/sighjs/sigh'>sighjs</a>.<br><br>In this talk I will describe the issues with existing asset pipelines (read: trash all the competition) and describe how sighjs improves upon the state of the art (read: gloriously inflate my ego).<br><br>This talk will last around 10 minutes long and it will be a little surreal. Here is <a href='https://vimeo.com/31535266j'>one of my other talks at HNN</a>."}, {"username": "sideshowcoder", "name": "Philipp Fehre", "title": "Server mocking with canned", "avatar": "https://avatars.githubusercontent.com/u/108488?v=3", "date": "May 27th 2015", "desc": "I've been frustrated with the complexity involved with just setting up a mock server so I wrote <a href='https://github.com/sideshowcoder/canned'>canned</a> sometime ago making faking a webserver just a matter of putting files in folders. This simple approach led to a whole bunch of usecase from <br><br>- frontend development first, backend later<br>- mock server for testing<br>- performance testing for mobile apps without backend influence<br><br>I think some of this would make an interesting talk and maybe some people might even find a use for canned in their own work. "}, {"username": "matteofigus", "name": "Matteo Figus", "title": "OpenComponents as microservices in the front-end world", "avatar": "https://avatars1.githubusercontent.com/u/1789893?v=3&", "date": "May 27th 2015", "desc": "Writing front-end code today is very challenging when you have to be resilient and robust in a big corporation. Working on a website that involves dozens of engineers based in three different continents, I learned that the complexity lies not only within the code itself. Allowing people to develop new features and deploy the code multiple times a day, keeping it up and running, is hard to achieve: we want small teams to be independent and not to interfere each other, in order to be quick and happy, but we also want to optimise cooperation when it is needed.<br /><br />In the front-end world components are very small units of code providing application functionality that are all connected in order to become a web-site.<br /><br />During this talk Iâ€™m going to speak about how we tried to approach to components at <a href='http://www.opentable.co.uk'>OpenTable</a>. After breaking our monolithic back-end into smaller parts, we tried to break the front-end into smaller parts too, called micro-sites. Then, following the SOA principles, we tried to elevate components as services, in order to make engineers able to create and consume them via clear and well-defined contracts and interfaces. This allowed us to put in place the infrastructure to optimise testing and to have hundreds of changes live every day without conflicts. The result is <a href='https://github.com/opentable/oc'>OpenComponents</a>, a framework that we recently open-sourced.<br /><br />"}]}